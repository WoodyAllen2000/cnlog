---
title: 有关于请求
date: '2025-01-30'
summary: 深入了解网络请求
tags: ["javascript", "计算机网络"]
---

### Fetch

我们用fetch发送请求，在获取响应时可以分成两个阶段，一个是先解析服务器响应头，还有就是获取response body。

```javascript
let response = await fetch(url);

// 判断响应头是否正确 
// response.status获取状态码，如果状态码为200-299，那么response.ok === true
if (response.ok) {
  let json = await response.json(); // 获取响应体
} else {
  alert("error"+response.status);
}
```

获取响应体有不同的方法，以不同格式访问body：

- **`response.text()`** —— 读取 response，并以文本形式返回 response，
- **`response.json()`** —— 将 response 解析为 JSON 格式，
- **`response.formData()`** —— 以 `FormData` 对象（在 [下一章](https://zh.javascript.info/formdata) 有解释）的形式返回 response，
- **`response.blob()`** —— 以 [Blob](https://zh.javascript.info/blob)（具有类型的二进制数据）形式返回 response，
- **`response.arrayBuffer()`** —— 以 [ArrayBuffer](https://zh.javascript.info/arraybuffer-binary-arrays)（低级别的二进制数据）形式返回 response，
- 另外，`response.body` 是 [ReadableStream](https://streams.spec.whatwg.org/#rs-class) 对象，它允许你逐块读取 body，我们稍后会用一个例子解释它。

然后是两种写法：

```javascript
let url = 'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits';

// 写法一：
let response = await fetch(url);
let message = await response.json();
alert(message);

// 写法二：
fetch(url)
	.then(response => response.json())
	.then(message => alert(message))
```

我们还可以在`response.headers` 中得到一个类似于map的对象。

我们也可以在request中设置headers

```javascript
let response = await fetch(url, {
  headers: {
    Authentication: 'secret'
  }
});
```

我们可以指定请求的方式，比如说我们要发出一个post请求，那么我们需要设置method为post，另外还有有request body，例如，下面我们要发送一个user对象：

```javascript
let user = {
  name: "John",
  surname: "Smith"
};

let response = await fetch('/article/fetch/post/user', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json;charset=utf-8'
  },
  body: JSON.stringify(user)
})

let result = await response.json();
alert(result.message);
```

### FormData

发送一个表单；

```html
<form>
  <input type="text" name="name" value="John">
  <input type="email" name="email" value="abc@abc.com">
  <input type="button">
</form>

<script>
  let form = document.querySelector('form');
  form.onsubmit = async function (e) {
    e.preventDefault();
    
    let response = await fetch('/article/formdata/post/user', {
      method: "POST",
      body: new FormData(form)
    });
    
    let result = await response.json();
    alert(result.message);
  };
</script>
```

### Fetch 终止

```javascript
// 1 秒后中止
let controller = new AbortController();
setTimeout(() => controller.abort(), 1000);

try {
  let response = await fetch('/article/fetch-abort/demo/hang', {
    signal: controller.signal
  });
} catch(err) {
  if (err.name == 'AbortError') { // handle abort()
    alert("Aborted!");
  } else {
    throw err;
  }
}
```

### Fetch 跨源请求

![image-20250329214014220](/Users/chengning/Library/Application Support/typora-user-images/image-20250329214014220.png)

请求的Header和响应头示例

```javascript
GET /request
Host: anywhere.com
Origin: https://javascript.info
...
200 OK
Content-Type:text/html; charset=UTF-8
Access-Control-Allow-Origin: https://javascript.info
```

![image-20250329214523768](/Users/chengning/Library/Application Support/typora-user-images/image-20250329214523768.png)

非安全请求要先发一个pre-flight，再发一个普通请求。

预检请求和实际请求示例：

```javascript
// 预检请求
OPTIONS /service.json
Host: site.com
Origin: https://javascript.info
Access-Control-Request-Method: PATCH
Access-Control-Request-Headers: Content-Type,API-Key
// 预检响应
200 OK
Access-Control-Allow-Origin: https://javascript.info
Access-Control-Allow-Methods: PUT,PATCH,DELETE
Access-Control-Allow-Headers: API-Key,Content-Type,If-Modified-Since,Cache-Control
Access-Control-Max-Age: 86400
// 实际请求
PATCH /service.json
Host: site.com
Content-Type: application/json
API-Key: secret
Origin: https://javascript.info
// 实际响应
200 OK
Access-Control-Allow-Origin: https://javascript.info
```

### URL对象

![image-20250330003918083](/Users/chengning/Library/Application Support/typora-user-images/image-20250330003918083.png)

### XMLHttpRequest

```javascript
let xhr = new XMLHttpRequest(); // 创建
xhr.open(method, URL, [async, user, password]); // 初始化
xhr.send([body]); // 发送请求
// 三个事件：load是请求完成，并且响应完全下载；error是请求完全无法发出；progress是下载请求期间定期触发，查看进度。
xhr.onload = function() {
  alert(`Loaded: ${xhr.status} ${xhr.response}`);
};

xhr.onerror = function() { // 仅在根本无法发出请求时触发
  alert(`Network Error`);
};

xhr.onprogress = function(event) { // 定期触发
  // event.loaded —— 已经下载了多少字节
  // event.lengthComputable = true，当服务器发送了 Content-Length header 时
  // event.total —— 总字节数（如果 lengthComputable 为 true）
  alert(`Received ${event.loaded} of ${event.total}`);
};
```

xhr设置请求头，获取响应头

```javascript
xhr.setRequestHeader('Content-Type', 'application/json');
xhr.getResponseHeader('Content-Type');
```

查看上传进度 `xhr.uopload` 

```javascript
xhr.upload.onprogress = function(event) {
  alert(`Uploaded ${event.loaded} of ${event.total} bytes`);
};

xhr.upload.onload = function() {
  alert(`Upload finished successfully.`);
};

xhr.upload.onerror = function() {
  alert(`Error during the upload: ${xhr.status}`);
};
```

xhr总结：

```javascript
let xhr = new XMLHttpRequest();

xhr.open('GET', '/my/url');

xhr.send();

xhr.onload = function() {
  if (xhr.status != 200) { // HTTP error?
    // 处理 error
    alert( 'Error: ' + xhr.status);
    return;
  }

  // 获取来自 xhr.response 的响应
};

xhr.onprogress = function(event) {
  // 报告进度
  alert(`Loaded ${event.loaded} of ${event.total}`);
};

xhr.onerror = function() {
  // 处理非 HTTP error（例如网络中断）
};
```

### 可恢复的文件上传

```javascript
let fileId = file.name + '-' + file.size + '-' + file.lastModified;
let response = await fetch('status', {
  headers: {
    'X-File-Id': fileId
  }
});

// 服务器已有的字节数
let startByte = +await response.text();

xhr.open("POST", "upload", true);

// 文件 id，以便服务器知道我们要恢复的是哪个文件
xhr.setRequestHeader('X-File-Id', fileId);

// 发送我们要从哪个字节开始恢复，因此服务器知道我们正在恢复
xhr.setRequestHeader('X-Start-Byte', startByte);

xhr.upload.onprogress = (e) => {
  console.log(`Uploaded ${startByte + e.loaded} of ${startByte + e.total}`);
};

// 文件可以是来自 input.files[0]，或者另一个源
xhr.send(file.slice(startByte));
```

### 长轮询

其流程为：

1. 请求发送到服务器。
2. 服务器在有消息之前不会关闭连接。
3. 当消息出现时 —— 服务器将对其请求作出响应。
4. 浏览器立即发出一个新的请求。

实现长轮询的客户端subscribe函数的示例代码：

```javascript
async function subscribe() {
  let response = await fetch("/subscribe");

  if (response.status == 502) {
    // 状态 502 是连接超时错误，
    // 连接挂起时间过长时可能会发生，
    // 远程服务器或代理会关闭它
    // 让我们重新连接
    await subscribe();
  } else if (response.status != 200) {
    // 一个 error —— 让我们显示它
    showMessage(response.statusText);
    // 一秒后重新连接
    await new Promise(resolve => setTimeout(resolve, 1000));
    await subscribe();
  } else {
    // 获取并显示消息
    let message = await response.text();
    showMessage(message);
    // 再次调用 subscribe() 以获取下一条消息
    await subscribe();
  }
}

subscribe();
```

### WebSocket

客户端WebSocket建立

```javascript
import WebSocket from "ws";

let socket = new WebSocket("wss://javascript.info/article/websocket/demo/hello");

socket.onopen = function(e) {
    console.log("[open] Connection established");
    console.log("Sending to server");
    socket.send("My name is John");
};

socket.onmessage = function(event) {
    console.log(`[message] Data received from server: ${event.data}`);
};

socket.onclose = function(event) {
    if (event.wasClean) {
        console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
      } else {
        // 例如服务器进程被杀死或网络中断
        // 在这种情况下，event.code 通常为 1006
        console.log('[close] Connection died');
      }
}

socket.onerror = function(error) {
    console.log(`[error] ${error.message}`);
};
```

处理限速状况

```javascript
// 每 100ms 检查一次 socket
// 仅当所有现有的数据都已被发送出去时，再发送更多数据
setInterval(() => {
  if (socket.bufferedAmount == 0) {
    socket.send(moreData());
  }
}, 100);
```

一个模拟：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <form name="publish">
        <input type="text" name="message">
        <input type="submit" value="Submit">
    </form>

    <div id="messages"></div>


    <script>
        let socket = new WebSocket("wss://javascript.info/article/websocket/chat/ws");
        document.forms.publish.onsubmit = function() {
            let outgoingMessage = this.message.value;

            socket.send(outgoingMessage);
            return false;
        }

        socket.onmessage = function(event) {
            let message = event.data;

            let messageElem = document.createElement('div');
            messageElem.textContent = message;
            document.getElementById('messages').prepend(messageElem);
        }
    </script>
</body>
</html>
```

### Server Sent Events

![image-20250330211501500](/Users/chengning/Library/Application Support/typora-user-images/image-20250330211501500.png)